함수와 프로토타입 체이닝
============
## 함수 정의
함수를 생성하는 방법은 3가지가 있다.
각각의 방식에 따라 함수 동작이 미묘하게 차이가 난다.
> - 함수 선언문
> - 함수 표현식
> - Function() 생성자 함수 => 자주 사용되지 않으므로 상식 수준으로만 알아두자

### 함수 리터럴
함수도 일반 객체처럼 값으로 취급된다. 때문에 객체 리터럴 방식으로 일반 객체를 생성할 수 있는 것처럼, 자바스크립트에서는 함수 리터럴을 이용해 함수를 생성할 수 있다.<br>
add() 함수는 function 키워드, 함수명, 매개변수 목록(파라미터), 함수몸체 로 이루어져 있다.

```
function add(x, y) {
    return x + y;
}
```

<br>
<br>

### 함수 선언문 방식
함수 선언문 방식으로 정의된 함수의 경우는 __반드시 함수명이 정의되어 있어야 한다.__<br>
함수명으로 함수를 호출한다.
```
// add() 함수 선언문
function add(x, y) {
    return x + y;
}

console.log(add(3, 4)); // 출력 값은 7

// 자바스크립트 엔진에 의해 함수 표현식 형태로 변경되기 때문에 외부에서 노출이 가능해진다. 함수 선언문은 아래와 같이 변경된다.
var add = function(x, y) {
    return x + y;
}
```

<br>
<br>

### 함수 표현식
함수 리터럴로 하나의 함수를 만들고, 여기서 생성된 함수를 변수에 할당하여 함수를 생성하는 것을 __함수 표현식__ 이라고 말한다.

#### 익명 함수 표현식
변수 add가 실제로 참조하는 두 수를 더하는 함수의 이름이 없다.<br> 이렇게 이름이 없는 함수 형태를 __익명 함수__ 라고 부른다.
arguments로 넘겨진 두 수를 더하는 익명 함수를 만들고 이를 add 변수에 할당한 것인데, 이게 바로 __익명 함수를 이용한 함수 표현식 방법(익명 함수 표현식)__ 이다. 
```
// add() 함수 표현식
// 함수 리터럴로 생성한 함수는 함수명이 없으므로 익명 함수다.
var add = function(x, y) {
    return x + y;
}

var plus = add;

console.log(add(3, 4)); // 7
console.log(plus(100, 100)); // 200
```


#### 기명 함수 표현식
함수 이름이 포함된 함수 표현식을 __기명 함수 표현식__ 이라 한다.
아래와 같이 함수 이름을 이용하면 함수 코드 내부에서 함수 이름으로 함수의 재귀적인 호출 처리가 가능하다. 
```
var ankoVar function = anko(param) {
    if(param <= 1) {
        return 1;
    }

    retrun param * anko(param - 1);
}

consolg.log(ankoVar(8));    
// 56   =>  함수 외부에서는 변수 ankoVar로 호출하고, 함수 내부에서 이뤄지는 재귀 호출은 anko() 함수 이름으로 처리한다는 것을 알 수 있다. 

console.log(anko(8));   
// undefined    =>  함수 외부에서 해당 함수를 호출 못한다.

```

<br>
<br>

## 함수 호이스팅
함수 호이스팅은 함수를 사용하기 전에 반드시 선언해야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수도 있다고 지적되며, 함수 표현식 사용을 권장한다.
```
anko(2, 3); // 5    =>  anko() 함수가 정의되지 않았음에도 함수를 호출하는 것이 가능하다. 이것으로 '함수 선언문 형태로 정의한 함수의 유호 범위는 코드의 맨 처음부터 시작한다'는 것을 확인할 수 있다.

function anko(x, y) {
    return x + y;
}

anko(3, 4); // 7
```
함수 표현식으로 다시 코드를 작성하면,
```
anko(2, 3); // anko is not a function

var anko = function(x, y) {
    return x + y;
}

anko(3, 4); // 7    =>  anko() 함수가 생성된 이후에는 정상적으로 동작
```

<br>
<br>

## 함수는 일급객체 !
1. 리터럴에 의해 생성
2. 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능
3. 함수의 인자로 전달 가능
4. 함수의 리턴값으로 리턴 가능
5. 동적으로 프로퍼티를 생성 및 할당 가능

이와 같은 특징이 있으므로 자바스크립트에서는 함수를 __일급객체__ 라고 부른다.
일급객체란 앞에서 나열한 기능이 모두 가능한 객체를 일급객체라고 부른다. 이러한 일급객체 특성으로 함수형 프로그래밍이 가능하다.

### 함수 객체만의 표준 프로퍼티
- name 프로퍼티는 함수의 이름
- caller 프로퍼티는 자신을 호출한 함수
- arguments 프로퍼티는 함수를 호출할 때 전달된 인자값 

<br>
<br>

## 생성자 함수
>Important :D 중요!
>
> prototype 객체는 함수 객체만 가지고 있다.
>
> 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성될 객체의 부모 역할을 하는 객체(프로토타입 객체)를 가리킨다.

<br>
프로토타입 객체는 constructor 프로퍼티를 갖는다. 
이 constructor 프로퍼티는 객체의 입장에서 자신을 생성한 객체를 가리킨다.

```
function Anko(name) {
  this.name = name;
}

var foo = new Anko('hound');

// Anko() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Anko() 생성자 함수이다.
console.log(Anko.prototype.constructor === Anko);

// foo 객체를 생성한 객체는 Anko() 생성자 함수이다.
console.log(foo.constructor === Anko);

// Anko() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.
console.log(Anko.constructor === Function);
```

<br>
<br>

## 콜백 함수
익명 함수의 대표적인 용도가 바로 __콜백 함수__ 다.
어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 시스템에서 호출되는 함수를 말한다.
또한, 특정 함수의 인자로 넘겨서, 코드 내부에서 호출되는 함수 또한 콜백 함수가 될 수 있다.
```
// 웹 페이지가 로딩될 때 등록한 이벤트 핸들러가 호출되면서 alert가 뜬다.
window.onload = function() {
    alert('이게 바로 콜백 함수야');
}
```
콜백 함수는 주로 비동기식 처리 모델에 사용된다. 비동기식 처리 모델이란 처리가 종료하면 호출될 함수(콜백함수)를 미리 매개변수에 전달하고 처리가 종료하면 콜백함수를 호출하는 것이다.

콜백함수는 콜백 큐에 들어가 있다가 해당 이벤트가 발생하면 호출된다. 콜백 함수는 클로저이므로 콜백 큐에 단독으로 존재하다가 호출되어도 콜백함수를 전달받은 함수의 변수에 접근할 수 있다.
```
function doSomething() {
  var name = 'anko';

  setTimeout(function () {
    console.log('My name is ' + name);
  }, 100);
}

doSomething(); // My name is anko
```